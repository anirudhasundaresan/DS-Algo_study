https://www.youtube.com/watch?v=OSGv2VnC0go

When looping backwards a list, use 'reversed'
for row in reversed(rows):
	print(colors)

use enumerate, better than using indices
izip instead of zip
sorted(list)
sorted(list, reverse=True)
sorted(list, key = len) if the list is made of words

read about iter - 2 argument form of iter -- takes in sentinel value

'partial' - takes in many arguments and returns fewer arguments?

blocks = []
for block in iter(partial(f.read, 32), ''):
	blocks.append(block)

In Python, there are else clauses for for loops as well.
'else' of 'for' is equivalent to 'no break' statement

Dictionary skills:
for keys in dict: -->  this is iterating
	loops over the keys

for keys in dict.keys(): also can be done -->  this is mutating
creates a copy of the dictionary keys in a list ... so if you wanna change/ mutate the dictionary now go ahead

but keys in dict and then del dict[key] will give error

for key,value in d.items() --> d.items() makes a list
for key, value in d.iteritems() --> this makes an iterator

building a dictionary from 2 lists:
d = dict(izip(names, colors))
another example:
d = dict(enumerate(names)) --> basically, whatever gives you tuples

counting with dictionaries:
d = defaultdict(int) # note that int is being used without any argument ... a dictionary is init with all 0
for color in colors:
	d[color]+=1

grouping with dictionaries:
d = defaultdict(list)
for name in names:
	key=len(names)
	d[key].append(name)




From http://treyhunner.com/2018/02/python-3-s-range-better-than-python-2-s-xrange/ :

mylist = [*{*mylist}]
this is an arg style set expansion followed by an arg style list expansion

zip, map, filter?
range is a class in Py3.

Talking about range function in Python 3.
More dunder methods (ones with __ __  in their names) in py3, thus adds to functionality of Py3.

If a=range(1,10,2)
and b = range(1,10,2)
a==a returns True and so does a==b, unlike Py2. Here, py3 check whether the start, stop and slices are same or not.

a = range(1,10,2)
a.start = 1
a.stop = 10
a.step = 2

range object in python supports splicing: range(10)[2:] --> range(2,10)
and range(10)[3:8:-1] --> range(3,8,-1)

Py3 'in' operator is implemented using __contains__ method, which range uses and not xrange in py2.
thus, -1 in xrange(10000000) returns False after unpacking the list, but -1 in range() returns False immediately.

To invert a range in py3,
a = range(1,20,2)
b = -a # will return errors
b = range(-a.start, -a.stop, -a.step) --> will return inverted list

In PY3, range object can accept integers of any type: long also, not in Py2.due to limitations on the int.



http://web.archive.org/web/20090209182018/http://immike.net/blog/2007/04/06/the-absolute-bare-minimum-every-programmer-should-know-about-regular-expressions/ --- RegEx stuff.

https://skymind.ai/wiki/accuracy-precision-recall-f1
https://www.toyota-ti.ac.jp/Lab/Denshi/COIN/people/yutaka.sasaki/F-measure-YS-26Oct07.pdf -- Interesting read on the F1 scores. 
Yes, accuracy is a great measure but only when you have symmetric datasets where values of false positive and false negatives are almost same. 
https://blog.exsilio.com/all/accuracy-precision-recall-f1-score-interpretation-of-performance-measures/
Accuracy is not reliable when using imbalanced data sets.
https://towardsdatascience.com/beyond-accuracy-precision-and-recall-3da06bea9f6c
