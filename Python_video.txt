References:
1. https://www.youtube.com/watch?v=OSGv2VnC0go
2. http://treyhunner.com/2018/02/python-3-s-range-better-than-python-2-s-xrange/
3. http://web.archive.org/web/20090209182018/http://immike.net/blog/2007/04/06/the-absolute-bare-minimum-every-programmer-should-know-about-regular-expressions/ --- RegEx stuff, if interested (no time to study that now).

The first video is by Raymond Hettinger, and it contains some tips on using Python3, mainly his contributions.
Given a task to be done in Python, there is only one obvious way to do it.

Here are some key points from the video:

- When looping backwards a list, use 'reversed':
for row in reversed(rows):
	print(colors)

- Use enumerate, it is better than using indices
- sorted(list) returns a list with sorted values, does not change the original list.
- list.sort() changes the original list; modifies in-place.
- sorted(list, reverse=True)
- sorted(list, key = len), if the list is made of words

- mylist = [*{*mylist}]; this is an arg style set expansion followed by an arg style list expansion
This is equivalent to mylist = list(set(mylist)) # note that in this process, list will not be sorted anymore.

** RANGE in Py3 **
- range is a class in py3.
- More dunder methods (ones with __ __  in their names) in py3, than in py2, thus adds to functionality of Py3.
- If a=range(1,10,2) and b = range(1,10,2); a==a returns True and so does a==b, unlike py2. Here, py3 checks whether the start, stop and slices are same or not.
a = range(1,10,2) --> a.start = 1; a.stop = 10; a.step = 2
- range object in python supports splicing: range(10)[2:] --> range(2,10) and range(10)[3:8:-1] --> range(3,8,-1)
- Py3 'in' operator is implemented using __contains__ method, which range uses and not used by xrange in py2.
Thus, -1 in xrange(10000000) returns False after unpacking the list, but -1 in range() returns False immediately.
- To invert a range in py3,
a = range(1,20,2)
b = -a # will return errors
b = range(-a.start, -a.stop, -a.step) --> will return inverted list
- In Py3, range object can accept integers of any type: long also, but not in py2, due to limitations on the int.

** DICTIONARY in Py3 **
- To build a dictionary from 2 lists:
d = dict(zip(names, colors))
another example: d = dict(enumerate(names)) --> basically, whatever gives you tuples

- for keys in dict: -->  this is iterating as it loops over the keys
- for keys in dict.keys(): also can be done -->  this is mutating; creates a copy of the dictionary keys in a list ... so if you wanna change/ mutate the dictionary now go ahead
- for keys in dict and then del dict[key] will give error since 'dict changed size during iteration'.
- for key,value in d.items() --> d.items() makes a list






- To run Python in interactive mode, run with '-i' flag.
eg: python -i example.py




read about iter - 2 argument form of iter -- takes in sentinel value

'partial' - takes in many arguments and returns fewer arguments?

blocks = []
for block in iter(partial(f.read, 32), ''):
	blocks.append(block)

In Python, there are else clauses for for loops as well.
'else' of 'for' is equivalent to 'no break' statement

counting with dictionaries:
d = defaultdict(int) # note that int is being used without any argument ... a dictionary is init with all 0
for color in colors:
	d[color]+=1

grouping with dictionaries:
d = defaultdict(list)
for name in names:
	key=len(names)
	d[key].append(name)

zip, map, filter?

